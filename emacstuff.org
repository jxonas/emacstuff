#+SEQ_TODO: FIXME FIXED

* Basic configuration
** Custom.el
#+begin_src emacs-lisp
  (setq custom-file (emacstuff-file "custom.el"))
  (load custom-file)
#+end_src
** Base directory
#+begin_src emacs-lisp
  (when (eq 'windows-nt system-type)
    (cd "u:/sandbox"))

  (setq sandbox-directory
        (case system-type
          (windows-nt "u:/sandbox/")
          (t "~/sandbox/")))

  (defsubst jx--sandbox-file (file)
    (expand-file-name file sandbox-directory))
#+end_src
** Server
#+begin_src emacs-lisp
  (server-start)
  (remove-hook 'kill-buffer-query-functions 'server-kill-buffer-query-function)
#+end_src
** Encoding
#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)

  ;; Treat clipboard input as UTF-8 string first; compound text next, etc.
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src
** Start Maximized
#+begin_src emacs-lisp
 (add-hook 'window-setup-hook 'toggle-frame-maximized t)
#+end_src
** Basic modes
#+begin_src emacs-lisp
  (setq inhibit-splash-screen t)
  (show-paren-mode 1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)

  (tooltip-mode -1)
  (setq tooltip-use-echo-area t)

  (put 'narrow-to-region 'disabled nil)
#+end_src
** Remove prompts
#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq confirm-nonexistent-file-or-buffer nil)
  (setq ido-create-new-buffer 'always)
  (setq inhibit-startup-message t
        inhibit-startup-echo-area-message t)
  (setq kill-buffer-query-functions
    (remq 'process-kill-buffer-query-function
           kill-buffer-query-functions))
#+end_src
** Recentf
#+begin_src emacs-lisp
  (require 'recentf)

  ;; get rid of `find-file-read-only' and replace it with something
  ;; more useful.
  (global-set-key (kbd "C-x C-r") 'ido-recentf-open)

  ;; enable recent files mode.
  (recentf-mode t)

  ; 50 files ought to be enough.
  (setq recentf-max-saved-items 50)

  (defun ido-recentf-open ()
    "Use `ido-completing-read' to \\[find-file] a recent file"
    (interactive)
    (if (find-file (ido-completing-read "Find recent file: " recentf-list))
        (message "Opening file...")
      (message "Aborting")))
#+end_src
** Backup and recycle bin
#+begin_src emacs-lisp
  (setq backup-directory-alist `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))

  (setq delete-by-moving-to-trash t)
#+end_src
* Eldoc
#+begin_src emacs-lisp
  (require 'eldoc)

  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
#+end_src
* Dependencies and packages
** Package setup
#+begin_src emacs-lisp
  (require 'package)

  (setq package-archives
        '(("gnu" . "http://elpa.gnu.org/packages/")
          ("marmalade" . "http://marmalade-repo.org/packages/")
          ("melpa" . "http://melpa.milkbox.net/packages/")))
    
  (package-initialize)
    
  (defvar emacstuff-packages
    '(paredit 
      highlight-parentheses 
      multiple-cursors 
      expand-region 
      boxquote
      smex
      imenu-anywhere
      visible-mark
      magit
      pretty-lambdada
      ;color-theme
      ;zenburn-theme
      iedit
      ;geiser
      ido-ubiquitous
      racket-mode
      rainbow-delimiters
     )
    "Libraries that should be installed by default.")
    
  (unless package-archive-contents
    (package-refresh-contents))

  (dolist (package emacstuff-packages)
    (unless (package-installed-p package)
      (package-install package)))
#+end_src
** Smex
#+begin_src emacs-lisp
  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)

  ;; Old M-x.
  (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
  #+end_src
** Paredit
#+begin_src emacs-lisp
  (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
  (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
  (add-hook 'racket-mode-hook           #'enable-paredit-mode)
  
  ; Eldoc
  (eldoc-add-command
   'paredit-backward-delete
   'paredit-close-round)
#+end_src
** Iedit
#+begin_src emacs-lisp
  (require 'iedit)

  (global-set-key (kbd "C-c ;") 'iedit-mode)
#+end_src
** Multiple cursors
#+begin_src emacs-lisp
  (global-set-key (kbd "<f8> m b") 'mc/edit-beginnings-of-lines)
  (global-set-key (kbd "<f8> m e") 'mc/edit-ends-of-lines)
  (global-set-key (kbd "<f8> m a") 'mc/mark-all-dwim)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
#+end_src
** Pretty lambda
#+begin_src emacs-lisp
  (require 'pretty-lambdada)
  (add-to-list 'pretty-lambda-auto-modes 'racket-mode)
  (pretty-lambda-for-modes)
#+end_src
** RainbowDelimiters
   #+begin_src emacs-lisp
     (require 'rainbow-delimiters)
     (add-hook 'racket-mode-hook 'rainbow-delimiters-mode)
   #+END_SRC
** Expand region
#+begin_src emacs-lisp
  (require 'expand-region)
  (global-set-key (kbd "C-=") 'er/expand-region)
#+end_src
* Occur
#+begin_src emacs-lisp
  (eval-when-compile
    (require 'cl))

  (defun get-buffers-matching-mode (mode)
    "Returns a list of buffers where their major-mode is equal to MODE"
    (let ((buffer-mode-matches '()))
     (dolist (buf (buffer-list))
       (with-current-buffer buf
         (if (eq mode major-mode)
             (add-to-list 'buffer-mode-matches buf))))
     buffer-mode-matches))

  (defun multi-occur-in-this-mode ()
    "Show all lines matching REGEXP in buffers with this major mode."
    (interactive)
    (multi-occur
     (get-buffers-matching-mode major-mode)
     (car (occur-read-primary-args))))


  (global-set-key (kbd "C-<f1>") 'occur)

  ;; global key for `multi-occur-in-this-mode' - you should change this.
  (global-set-key (kbd "C-<f2>") 'multi-occur-in-this-mode)
#+END_SRC
* Ido
#+begin_src emacs-lisp
  (when (> emacs-major-version 21)
    (ido-mode t)
    (setq ido-enable-prefix nil
          ido-enable-flex-matching t
          ido-create-new-buffer 'always
          ido-use-filename-at-point t
          ido-max-prospects 10))


  (setq ido-everywhere t)
  (setq ido-max-directory-size 100000)
  (ido-mode 'both)
  (setq ido-default-file-method 'selected-window)
  (setq ido-default-buffer-method 'selected-window)

  (defun jx--prepare-files-for-ido (files)
    (labels ((make (file)
                   (cons file
                         (nreverse 
                          (split-string (expand-file-name file) "/"))))
             (file (x) (car x))
             (head (x) (cadr x))
             (tail (x) (cddr x))
             (pop-head (x)
                       (let ((tail (tail x)))
                         (setf (cdr x) tail))
                       x))
      (let ((xs (mapcar #'make files))
            (table (make-hash-table :test #'equal))
            (final nil))
        (dolist (x xs)
          (let ((key (head x)))
            (push (pop-head x) (gethash key table))))
        (loop 
         while (> (hash-table-count table) 0)
         do 
         (maphash (lambda (key value)
                    (when (= (length value) 1)
                      (let ((x (first value)))
                        (push (cons key (file x)) final))
                      (remhash key table))) table)
         (maphash (lambda (key value)
                    (when (> (length value) 1)
                      (dolist (x value)
                        (let ((new-key (format "%s/%s" (head x) key)))
                          (push (pop-head x) (gethash new-key table))))
                      (remhash key table))) table))
        final)))

  (defun jx--completing-read-file/short-path (prompt files)
    (let* ((options (jx--prepare-files-for-ido files))
           (option-list (mapcar #'first options))
           (selection (ido-completing-read prompt option-list nil t)))
      (when selection
        (cdr (assoc selection options)))))
    
  (defun jx--completing-read-file (prompt files &optional full-path)
    (or (and full-path (ido-completing-read prompt files nil t))
        (jx--completing-read-file/short-path prompt files)))

#+end_src
* Racket mode
#+begin_src emacs-lisp
  (require 'racket-mode)

  (global-set-key (kbd "<f9> r") 
                  (lambda ()
                    (interactive)
                    (find-file (jx--sandbox-file "sandbox.rkt"))))

  (defun racket-repl--bol ()
    (interactive)
    (when (= (point) (comint-bol)) (beginning-of-line)))

  (defun racket-repl--last-prompt-end ()
    (cond ((and (boundp 'comint-last-prompt) (markerp (cdr comint-last-prompt)))
           (marker-position (cdr comint-last-prompt)))
          ((and (boundp 'comint-last-prompt-overlay) comint-last-prompt-overlay)
           (overlay-end comint-last-prompt-overlay))
          (t (save-excursion (racket-repl--bol) (point)))))

  (defun racket-repl--last-prompt-start ()
    (cond ((and (boundp 'comint-last-prompt) (markerp (car comint-last-prompt)))
           (marker-position (car comint-last-prompt)))
          ((and (boundp 'comint-last-prompt-overlay) comint-last-prompt-overlay)
           (overlay-start comint-last-prompt-overlay))
          (t (save-excursion (racket-repl--bol) (point)))))

  (defun racket-repl-clear-buffer ()
    "Delete the output generated by the scheme process."
    (interactive)
    (let ((inhibit-read-only t))
      (delete-region (point-min) (racket-repl--last-prompt-start))
      (when (< (point) (racket-repl--last-prompt-end))
        (goto-char (racket-repl--last-prompt-end)))
      (recenter t)))

  (define-key racket-repl-mode-map "\C-c\M-o" 'racket-repl-clear-buffer)
#+END_SRC
* Org-mode
** Agenda
#+begin_src emacs-lisp
  (setq org-agenda-archives-mode nil)
  (setq org-agenda-skip-comment-trees nil)
  (setq org-agenda-skip-function nil)

  (global-set-key (kbd "<f9> a s") 'jx-ido-find-agenda-file)

  (defun jx-ido-find-agenda-file (full-path)
    (interactive "P")
    (let ((file (jx--completing-read-file "Agenda file: " (org-agenda-files t 'ifmode) full-path)))
      (when file
        (find-file file))))
#+end_src
** Directories
#+begin_src emacs-lisp
  (setq org-directory "~/.org")
  (setq org-default-notes-file "~/.org/refile.org")
#+end_src

** TODO Keywords
#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
          (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING")))

  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ("MEETING" :foreground "forest green" :weight bold)
                ("PHONE" :foreground "forest green" :weight bold))))

  (setq org-use-fast-todo-selection t)
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+end_src
** TODO state triggers
#+begin_src emacs-lisp
  (setq org-todo-state-tags-triggers
        '(("CANCELLED" ("CANCELLED" . t))
          ("WAITING" ("WAITING" . t))
          ("HOLD" ("WAITING") ("HOLD" . t))
          (done ("WAITING") ("HOLD"))
          ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
          ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
          ("DONE" ("WAITING") ("CANCELLED") ("HOLD"))))
#+end_src
** Capture
#+begin_src emacs-lisp
  ;; Capture templates for: TODO tasks, Notes, appointments, phone calls, meetings, and org-protocol
  (setq org-capture-templates
        '(("t" "todo" entry (file "~/.org/refile.org")
           "* TODO %?\n  %U\n  %a\n")
          ("r" "respond" entry (file "~/.org/refile.org")
           "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n")
          ("n" "note" entry (file "~/.org/refile.org")
           "* %? :NOTE:\n%U\n%a\n")
          ("j" "Journal" entry (file+datetree "~/.org/diary.org")
           "* %?\n%U\n")
          ("w" "org-protocol" entry (file "~/.org/refile.org")
           "* TODO Review %c\n%U\n")
          ("m" "Meeting" entry (file "~/.org/refile.org")
           "* MEETING with %? :MEETING:\n%U")
          ("p" "Phone call" entry (file "~/.org/refile.org")
           "* PHONE %? :PHONE:\n%U")
          ("h" "Habit" entry (file "~/.org/refile.org")
           "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"<%Y-%m-%d %a .+1d/3d>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n")))
#+end_src
#+begin_src emacs-lisp
  ;; Remove empty LOGBOOK drawers on clock out
  (defun jx--remove-empty-drawer-on-clock-out ()
    (interactive)
    (save-excursion
      (beginning-of-line 0)
      (org-remove-empty-drawer-at (point))))

  (add-hook 'org-clock-out-hook 'jx--remove-empty-drawer-on-clock-out 'append)
#+end_src

** Refile
#+begin_src emacs-lisp
  ; Targets include this file and any file contributing to the agenda - up to 9 levels deep
  (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                   (org-agenda-files :maxlevel . 9))))

  ; Use full outline paths for refile targets - we file directly with IDO
  (setq org-refile-use-outline-path t)

  ; Targets complete directly with IDO
  (setq org-outline-path-complete-in-steps nil)

  ; Allow refile to create parent tasks with confirmation
  (setq org-refile-allow-creating-parent-nodes (quote confirm))

  ; Use IDO for both buffer and file completion and ido-everywhere to t
  (setq org-completion-use-ido t)
  (setq ido-everywhere t)
  (setq ido-max-directory-size 100000)
  (ido-mode (quote both))
  ; Use the current window when visiting files and buffers with ido
  (setq ido-default-file-method 'selected-window)
  (setq ido-default-buffer-method 'selected-window)
  ; Use the current window for indirect buffer display
  (setq org-indirect-buffer-display 'current-window)

  ;;;; Refile settings
  ; Exclude DONE state tasks from refile targets
  (defun jx--verify-refile-target ()
    "Exclude todo keywords with a done state from refile targets"
    (not (member (nth 2 (org-heading-components)) org-done-keywords)))

  (setq org-refile-target-verify-function 'jx--verify-refile-target)
#+END_SRC
** Key bindings
#+begin_src emacs-lisp
  (global-set-key (kbd "<f12>") 'org-agenda)
  (global-set-key (kbd "<f8> s") 'org-save-all-org-buffers)
  (global-set-key (kbd "<f8> <f8>") 'org-narrow-to-subtree)
  (global-set-key (kbd "C-<f8>") 'widen)

  ;; Org capture
  (global-set-key (kbd "C-c c") 'org-capture)
#+end_src
* Misc
#+begin_src emacs-lisp
  (setq next-line-add-newlines t)
  (visible-mark-mode 1)
  (global-set-key (kbd "M-i") 'imenu-anywhere)
#+END_SRC

#+begin_src emacs-lisp
  (mapcar 
    (lambda (s) (put s 'racket-indent-function 'defun))
   '(arguments))

  (mapcar 
   (lambda (s) (put s 'racket-indent-function 2))
   '(parameterize-from-config struct))

#+end_SRC
* Indentation and buffer cleanup
#+begin_src emacs-lisp
  (defun jx-untabify-buffer ()
    (interactive)
    (untabify (point-min) (point-max)))

  (defun jx-indent-buffer ()
    (interactive)
    (indent-region (point-min) (point-max)))

  (defun jx-cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer."
    (interactive)
    (jx-indent-buffer)
    (jx-untabify-buffer)
    (delete-trailing-whitespace))

  (defun jx-cleanup-region (beg end)
    "Remove tmux artifacts from region."
    (interactive "r")
    (dolist (re '("\\\\│\·*\n" "\W*│\·*"))
      (replace-regexp re "" nil beg end)))

  (global-set-key (kbd "C-x M-t") 'jx-cleanup-region)
  (global-set-key (kbd "C-c n") 'jx-cleanup-buffer)

  (setq-default show-trailing-whitespace t)
#+end_src

* General key bindings
#+begin_src emacs-lisp
  (global-set-key (kbd "<f5>") (lambda () (interactive) (revert-buffer 'ignore-auto 'noconfirm)))
  (global-set-key (kbd "C-<f5>") (lambda () (interactive) (revert-buffer-with-coding-system 'utf-8 'force)))

  (global-set-key (kbd "<f1>") 'menu-bar-mode)

  (global-set-key (kbd "<f8> x e")
    (lambda () 
      (interactive)
      (find-file (emacstuff-file "emacstuff.org"))))

  (global-set-key (kbd "<f8> x x")
    (lambda () 
      (interactive)
      (kill-buffer "emacstuff.org")))

  (global-set-key (kbd "<f9> s")
    (lambda ()
      (interactive)
      (switch-to-buffer "*scratch*")))

  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)

  (global-set-key (kbd "C-x g") 'magit-status)
#+end_src
* Specific settings
#+begin_src emacs-lisp
  (defvar emacstuff--user-settings-file (emacstuff-file (concat (user-login-name) ".org")))
  (when (file-exists-p emacstuff--user-settings-file)
    (org-babel-load-file emacstuff--user-settings-file))
#+end_src







